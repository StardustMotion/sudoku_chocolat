
seems like a 2²*2² sudoku grid has 288

to compute 3²x3² (standard) sudokus possibilities stats :

	Model[My sudoku of size 3] features:
	Variables : 81
	Constraints : 27
	Building time : 0.121s
	User-defined search strategy : no
	Complementary search strategy : no
- Incomplete search - Limit reached.
	Model[My sudoku of size 3]
	Solutions: 260,833
	Building time : 0.121s
	Resolution time : 15.026s
	Nodes: 535,180 (35,616.0 n/s) 
	Backtracks: 548,607
	Backjumps: 0
	Fails: 13,475
	Restarts: 0
	
There are too much 3²x3² sudokus. Within 15 seconds Choco and my computer could find 260.000 sudoku possibilities.
That should be enough for the context of this course to generate. Maybe with some random we could find different ones.
We need random anyway to actually "generate" stuff, if that's deterministic it's not interesting. The algorithm must
adapt to any input valid sudoku.

5 seconds time limit 3²x3² solution search :

- Incomplete search - Limit reached.
	Model[My sudoku of size 3]
	Solutions: 50,854
	Building time : 0.128s
	Resolution time : 5.021s
	Nodes: 104,844 (20,883.0 n/s) 
	Backtracks: 107,891
	Backjumps: 0
	Fails: 3,097
	Restarts: 0
	
the same process, BUT with restarts when a solution is found :

- Incomplete search - Limit reached.
	Model[My sudoku of size 3]
	Solutions: 1,699
	Building time : 0.155s
	Resolution time : 5.024s
	Nodes: 70,861 (14,104.2 n/s) 
	Backtracks: 70,900
	Backjumps: 0
	Fails: 78
	Restarts: 1,699
	
	
	- Incomplete search - Limit reached.
	Model[My sudoku of size 3]
	Solutions: 2,097
	Building time : 0.131s
	Resolution time : 5.021s
	Nodes: 87,222 (17,370.6 n/s) 
	Backtracks: 87,274
	Backjumps: 0
	Fails: 78
	Restarts: 2,097
	
	- Incomplete search - Limit reached.
	Model[My sudoku of size 3]
	Solutions: 1,919
	Building time : 0.262s
	Resolution time : 5.019s
	Nodes: 79,883 (15,914.9 n/s) 
	Backtracks: 79,939
	Backjumps: 0
	Fails: 78
	Restarts: 1,919
	
Much less sudokus  grid are found when prompted to restart from the root tree of search.
However the restart thing doesn't give any random, the generated solutions still are the same





SEARCH STRATEGIES of CHOCO :
"Choco 4.10.2 builds a binary search tree: each decision can be refuted (if x=5 leads to no solution, then x!=5 is applied). The classical search is based on Depth First Search."
from the doc.

To generate a "random" sudoku valid, completed grid, I first thought about defining a custom search strategy. This strategy would pick a random cell, and assign a value.
Then pick another one, and assign it by respecting sudoku rules. So on until the whole grid is full. When it's full then we backtrack and generate all the possibilities within time limit.


At the end, I ended up figuring out a clean and legitimate way to take a "random valid" sudoku, thorough the reservoir sampling algorithm.
It allows to pick a random element among n when the value of n is unknown at the beginning. 
Sudoku grid 1 is taken with 1/1 chance. Sudoku grid 2 will replace the previously taken grid with 1/2 chance. Sudoku grid 3 will replace the previous chosen with 1/3 chance.
This goes on until we generated all the sudoku grid or, for usually sudokus of dimension 3, after the time limit is reached.
This searching strategy is still deterministic, BUT the sudoku grid we retain is a random one among all the computed solutions.









SEARCHING ALGORITHM :
SUDOKU SOLUTION N° 1
==========================================
     3  7  2      1  5  6      4  9  8 
     8  4  5      2  3  9      6  7  1 
     1  9  6      8  7  4      3  2  5 

==========================================
     5  3  1      6  2  7      8  4  9 
     4  2  8      3  9  5      7  1  6 
     7  6  9      4  8  1      2  5  3 

==========================================
     9  1  4      7  6  3      5  8  2 
     6  8  7      5  1  2      9  3  4 
     2  5  3      9  4  8      1  6  7 

SUDOKU SOLUTION N° 2
==========================================
     3  7  2      1  5  6      4  9  8 
     8  4  5      2  3  9      6  7  1 
     1  9  6      8  7  4      3  2  5 

==========================================
     5  3  1      6  2  7      8  4  9 
     4  2  9      3  8  5      7  1  6 
     7  6  8      4  9  1      2  5  3 

==========================================
     9  1  4      7  6  3      5  8  2 
     6  8  7      5  1  2      9  3  4 
     2  5  3      9  4  8      1  6  7 

SUDOKU SOLUTION N° 3
==========================================
     3  7  2      1  5  6      4  9  8 
     8  4  5      2  3  9      6  7  1 
     1  9  6      8  7  4      3  2  5 

==========================================
     5  3  1      6  2  7      8  4  9 
     4  2  9      3  8  5      7  1  6 
     7  6  8      9  4  1      2  5  3 

==========================================
     9  1  4      7  6  3      5  8  2 
     6  8  7      5  1  2      9  3  4 
     2  5  3      4  9  8      1  6  7 
	 
By default the filled grids generated by the DFS of Choco are quite similar.
Let's add a "reset on solution" thing.
	 
	 SUDOKU SOLUTION N° 1
==========================================
     3  7  2      1  5  6      4  9  8 
     8  4  5      2  3  9      6  7  1 
     1  9  6      8  7  4      3  2  5 

==========================================
     5  3  1      6  2  7      8  4  9 
     4  2  8      3  9  5      7  1  6 
     7  6  9      4  8  1      2  5  3 

==========================================
     9  1  4      7  6  3      5  8  2 
     6  8  7      5  1  2      9  3  4 
     2  5  3      9  4  8      1  6  7 

SUDOKU SOLUTION N° 2
==========================================
     7  9  1      3  5  8      2  6  4 
     4  6  5      1  2  9      7  8  3 
     3  2  8      6  4  7      1  9  5 

==========================================
     1  4  6      9  7  3      5  2  8 
     9  5  7      4  8  2      3  1  6 
     8  3  2      5  1  6      4  7  9 

==========================================
     2  8  3      7  9  5      6  4  1 
     6  1  9      2  3  4      8  5  7 
     5  7  4      8  6  1      9  3  2 

SUDOKU SOLUTION N° 3
==========================================
     9  8  4      1  3  5      6  7  2 
     2  3  5      7  6  8      1  4  9 
     7  1  6      4  9  2      5  3  8 

==========================================
     6  5  2      8  1  4      7  9  3 
     4  9  3      5  7  6      8  2  1 
     8  7  1      9  2  3      4  5  6 

==========================================
     1  6  7      2  5  9      3  8  4 
     3  4  9      6  8  7      2  1  5 
     5  2  8      3  4  1      9  6  7 

	 
	 that looks much better and diverse. It's still deterministic as in running the program again still gives the very same grids
	 for each iteration, but the grids are diversified enough. Of course restarting on solution takes much more time as the value assignment tree
	 is rebuilt from the root.
	 
	 
	 
	 
	 
	 
Now we'll take the approach where we peak hole in a valid grid to generate sudoku grids for humans.
This means we'll basically re-use before's model ("generate a grid from an empty one"), however we'll now add more constraints :
each cell being attributed is a constraint, a helpful one (the cell i,j must be equal to value X : this diminushes the amount of solutions)
I propose to simply give a n²*n² array to the solution generator, this array either include Null (or None whatever Java uses) if the cell is empty,
or its value if it's not initially empty. And boom we build one constraint per cell pre-defined this way.


UPDATE : ok so the code was restructred and now it's easier to peak holes in the sudoku.
We can just generate a filled sudoku, manually (or automatically) peak the holes by modifying the int[][] array, and we can now
rerun the model at each modification! Nice, very good
We'll see if we can just alter the model instead of rebuilding it everytime though.